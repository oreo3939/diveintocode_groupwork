# -*- coding: utf-8 -*-
"""main_demo

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14Z1Tji4UqT226y3SDC93CI3TlpptmK5t
"""

import pygame.mixer
import numpy as np
# ラズパイ時に復活
import picamera
from PIL import Image
from time import sleep, perf_counter

from translate import *
from bottle_master import bottle_master
# ラズパイ時に復活
from shutter2image import shutter2image
import os
import datetime
import pandas as pd

from keras.preprocessing import image
from keras.models import load_model
from keras.preprocessing.image import img_to_array
import efficientnet.keras

# modelを初期値をNoneに
# time_debugモードを追加

class MAIN:
    """
    マスタークラス

    """
    def __init__(self, model='YOLO', lang="e", time_debug=False):
        self.model_dict = {'y':"YOLO", 'e':"EFF", 'r':"Random"}
        self.language_dict = {'k':'Kinyarwanda', 'e':'English', 'f':'French', 'j':'Japanese'}
        self.model = model
        self.lang = lang
        self.check_list = ["y", "n"]
        self.time_debug = time_debug

    def mode_select(self):
      """
      初期起動モードを選択させる関数
      標準入力から引数を取って分岐する
      """
      mode_list = ["1", "2", "3"]
      print("\n----------Current status---------")
      print("model : {}\nlanguage : {}".format(self.model, self.language_dict[self.lang]))
      
      print("\n----------Please choice start up mode----------")
      print(" 1 : Start in cash register mode")
      print(" 2 : Start in set up mode")
      print(" 3 : Start in image mode")
      print("--------------------")
      mode = input("Please select and enter the number : ")

      while mode not in mode_list:
          print("\nInvalid number.")
          mode = input("\nPlease enter the correct characters : ")

      if mode == "1":
        register = Register(self.model, self.lang, self.time_debug)
        register.main()
      elif mode == "2":
        setup = setup_mode()
        setup.setup_mode_select()

      elif mode == "3":
        pass

# モデルのクラスを記載

class Random_model():
    def __init__(self):
        self.loaded_model = 100
    def Preprocess(self, pil_image=None):
        #　モデルに応じてリサイズ処理をしてインスタンス変数
        self.image_array = np.random.randn(100, 100)
    def predict(self):
        # インスタンス変数のarrayから予測、予測されたラベルを返す
        random_index = np.random.choice(10, np.random.randint(1, 4))
        return list(random_index)


class EFF_function(MAIN):
    def __init__(self):
        super().__init__()
        self.hold = np.load("/home/pi/dive_groupwork/efficient_env/group_work/models/hold_vector.npy")
        self.clf = load_model('/home/pi/dive_groupwork/efficient_env/group_work/models/eff3_model.h5')
    
    def Preprocess(self, im_array):
        tmp_array = im_array.resize((224, 224))
        tmp_array = img_to_array(tmp_array)
        tmp_array = tmp_array.astype('float32')/255.0
        self.im_array = tmp_array.reshape((1,224,224,3))
    
    def cosine_similarity(self, x1, x2):
        """
        test_dataと学習済み商品のコサイン類似度を算出
        n_dimはベクトルの次元　1000~1500程度
        x1: 対象の商品のベクトル   shape(1, n_dim)
        x2: 学習済みの商品のベクトル(hold_vector) shape(5, n_dim)
        return: 5つの商品に対するコサイン類似度 shape(1,5)
        """
        
        if x1.ndim == 1:
            x1 = x1[np.newaxis]
        if x2.ndim == 1:
            x2 = x2[np.newaxis]
        x1_norm = np.linalg.norm(x1, axis=1)
        x2_norm = np.linalg.norm(x2, axis=1)
        cosine_sim = np.dot(x1, x2.T)/(x1_norm*x2_norm+1e-10)
        return cosine_sim     
            
            
    def judgment(self, predict_vector, hold_vector, thresh):
        """
        predict_vector : shape(1, n_dim)
        hold_vector : shape(5, n_dim)
        """
        cos_similarity = self.cosine_similarity(predict_vector, hold_vector) # shape(1, 5)
        print(cos_similarity[0])
        # 最も値が高いindexを取得
        high_index = np.argmax(cos_similarity[0]) # int
        # cos類似度が閾値を超えるか
        if cos_similarity[0][high_index] > thresh:
            return high_index
        
        else:
            return 5  

    def predict(self):
        # predict
        img_pred = self.clf.predict(self.im_array)
        jd = self.judgment(predict_vector=img_pred, hold_vector=self.hold, thresh=0.992)
        # return jd
        return [jd]

# class YOLO:


# Registerクラス
class Register(MAIN):
    def __init__(self, model, lang, time_debug):
        # 親クラスのインスタンス変数を読み込み
        super().__init__(model, lang, time_debug)
        # bottle_master_dfを呼び込む
        self.bottle_master_df = bottle_master.bottle_master_df()
            
    def main(self):
        #　モデルのオブジェクトを呼び込む、モデルクラス後に追加
        print(self.model)
        if self.model == "Random":
            self.model_object = Random_model()
        elif self.model == "EFF":
            self.model_object = EFF_function()
        else:
            pass
        
        print('bottle_master')
        print(self.bottle_master_df)
        while True:
            # 空のdfを作成
            total_df = pd.DataFrame(columns=['name', 'price'])
            while True:
                # 「商品を置いてenterを押してください」
                scene = "scan_start"
                input(translate_language(self.lang, scene))

                # 時間を図る self.time_debugに応じて対応
                if self.time_debug:
                    time_start = perf_counter()
                # 写真撮影をしてnumpy_arrayで受け取る
                image_array = shutter2image.shutter_array()

                # numpy_arrayをPILへ変換してモデルの入力用に加工
                img = Image.fromarray(image_array)

                # 画像表示
                img.show()
                
                # modelオブジェクトのPreprocessでPILをresize, numpy_arrayに変換
                self.model_object.Preprocess(img)
                
                # 予測されたindexのリストを読み込む
                predict_index_list = self.model_object.predict()
                print('debug 予測されたラベルインデックスのリスト {}'.format(predict_index_list))
                # 予測されたindexのリストからdfを作成
                predict_df = self.bottle_master_df.iloc[predict_index_list, [2, 3]].reset_index(drop=True)
                
                # 小計をdiplay
                scene = "read_message"
                # print(translate_language(self.lang, scene).format('test_bottle', random_price))
                print('読み取られた商品の一覧は以下になります')
                print(predict_df)

                # 時間計測
                if self.time_debug:
                    time_end = perf_counter()
                    # 商品を読み取るまで {}[s] 経過しました
                    scene = "time"
                    print(translate_language(self.lang, scene).format(time_end-time_start))

                while True:
                # 読み取られた商品が正しい場合は「y」、誤っていた場合は「n」を押してください
                    scene = "correct?"
                    key = input(translate_language(self.lang, scene))

                    if key != 'y' and key != 'n':
                        # 正しく入力されていません
                        scene = "input_error"
                        print(translate_language(self.lang, scene))
                    else:
                        break
                
                if key == 'y':
                    total_df = pd.concat([total_df, predict_df], axis=0).reset_index(drop=True)
                    print(total_df)
                    # 小計
                    scene = "subtotal"
                    print(translate_language(self.lang, scene).format(total_df["price"].sum()))

                    while True:
                        # 続けて商品をスキャンする場合は「y」、会計する場合は「f」、\n キャンセルする商品がある場合は「ｘ」を押して下さい。
                        scene = "continue?"
                        key = input(translate_language(self.lang, scene))
                        if key != 'y' and key != 'f' and key != 'x':
                            # 正しく入力されていません
                            scene = "input_error"
                            print(translate_language(self.lang, scene))
                        # 商品をdeletする処理
                        elif key == 'x':
                            while True:
                                print(total_df)
                                # scene設定
                                key = input('商品から消去する商品の番号を押してください, 消去しない場合は「n」を押してください')
                                key_list = [str(i) for i in range(len(total_df))] + ['n']
                                if key not in key_list:
                                    # 正しく入力されていません
                                    scene = "input_error"
                                    print(translate_language(self.lang, scene))
                                elif key == 'n':
                                    break
                                else:
                                    print('以下の商品を消去しました')
                                    print(total_df[int(key):int(key)+1])
                                    #　total_dfから消去
                                    total_df = total_df.drop(index=int(key))
                                    #　indexをreset
                                    total_df = total_df.reset_index(drop=True)
                        else:
                            break

                    if key == 'f':
                        # 合計
                        print(total_df)
                        scene = "total"
                        print(translate_language(self.lang, scene).format(total_df['price'].sum()))

                        # ありがとうございました
                        scene = "thanks"
                        print(translate_language(self.lang, scene))
                        print()
                        break
                    elif key == 'y':
                        # 次の商品を指定の位置に置いてください。
                        scene = "next"
                        print(translate_language(self.lang, scene))

if __name__ == '__main__':
    MAIN(model='EFF', lang="j", time_debug=True).mode_select()